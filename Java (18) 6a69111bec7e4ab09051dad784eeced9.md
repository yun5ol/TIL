# Java (18)

작업중: In progress
태그: Dev, 백엔드프로그래밍, 웹&모바일, 자바프로그래밍기초
학습일: 01/25/2023

## 인터페이스

- **인터페이스?** 객체 사용 규칙을 정의하는 문법
    - 일관성 있는 프로그래밍 가능
    - 호환성, 교체가 쉽다
    - **loose coupling** 느슨한 연결을 지원한다
        
        ⇒ 클래스 간의 종속성을 제거하므로, 유지보수가 용이하다
        

<aside>
📍 프로그램을 짜다가 인터페이스를 만나게 되면,
→누가 호출자이고, 누가 피호출자인지 확인하라.
⇒ 본인이 맡은 개발 일이 호출자를 만드는 것인지, 피호출자를 만드는 것인지 확인하라.

</aside>

### 인터페이스 정의

- `interface 사용규칙명 {...}`
    
    ⇒ 메서드 **형식을** 의미한다.
    
    ⇒ 메서드의 **몸체는** 정의하지 **않는다**.
    
    ⇒ 메서드의 몸체는 이 **규칙에** 따라 만드는 클래스에서 정의하는 것이다.
    
    ⇒ 규칙은 전체 공개되어야 한다 : **public**
    
    ⇒ 규칙만 정의할 뿐, 구현되면 안된다 : **abstract** (둘 다 생략 가능)
    

### 인터페이스 구현

- `class 클래스명 implements 인터페이스명, 인터페이스명, ... {...}`
    
    eg. worker 규칙을 따른다 ⇒ 줄여서 “worker 구현체” 라고 부른다
    
- 인터페이스에 선언된 **모든 추상 메서드를 반드시** **구현**해야 한다
    - 인터페이스 구현을 선언하지 않는다면, 공식적으로 해당 인터페이스의 구현체가 아니기 때문에 레퍼런스에 담을 수 없다. 
    ⇒ 구현하지 않으면 추상 메서드인채로 존재
    (추상 메서드를 갖고 있는 클래스는 추상 클래스만이 가능)
        
        ⇒ concrete 클래스가 될 수 없다
        
        <aside>
        📍 인터페이스 레퍼런스?
        해당 인터페이스에 따라 작성된(사용규칙을 준수하는) 클래스의 인스턴스 주소를 저장한다.
        
        </aside>
        
- public 보다 접근 범위를 좁힐 수는 없다.

### 인터페이스 사용

- 인터페이스 레퍼런스 선언
- 인터페이스를 구현한 클래스의 객체라면, 언제든 해당 인터페이스의 **레퍼런스에 담을 수** 있다.
- **인터페이스는** 규칙이기 때문에 구체적인 구현 내용이 없기 때문에, **인스턴스를 생성할 수 없다.**

### 인터페이스 필드

- `public static final` 이다  (주로 모두 생략)
    
    ⇒ 상수이므로 값을 변경할 수 없다
    
    ⇒ 인스턴스를 생성할 수 없기 때문에 인스턴스 필드를 선언할 수 없다.
    
    ⇒ 규칙이기 때문에 무조건 public 이다.
    
    ⇒ 인스턴스 필드가 아니기 때문에 값을 변경할 수 없다.
    

### 기본 메서드(default method)

→ 기존 프로젝트에 새 규칙이 추가될 경우, 모든 callee에 추가 구현해야한다.

따라서, 기존 프로젝트에 영향을 끼치지 않으면서 기존 규칙에 새 메서드를 추가할 때 기본 메서드를 사용한다.

- 인터페이스에서 미리 구현한 메서드이기 때문에 **클래스에서 구현을 생략할 수 있다.**
- 반대로 구현을 강제할 수 없다는 것이 단점이다.

### private 메서드

인터페이스 내부에서 사용할 메서드라면 **private** 접근 범위를 갖는 구현 메서드를 정의할 수 있다.

### static 메서드

- 스태틱 메서드는 가능한 그 메서드가 선언된 클래스 이름으로 호출하는 것이 좋다.
- 인터페이스에 정의된 **static** 메서드는,
    
    ⇒ 인터페이스를 구현한 클래스를 통해 호출할 수 없다.
    
    ⇒ 해당 인터페이스 명으로만 호출 가능하다
    

## Iterator
22.데이터 목록(컬렉션)에서 데이터를 꺼낼 때 호출하는 메서드 규칙을 정의

### Iterator 데이터 조회 기능을 규격화

⇒ 구현 방식에 상관없이 일관된 조회 가능

|  | ArrayList / LinkedList | Stack | Queue |
| --- | --- | --- | --- |
| 조회 | index를 이용하여 데이터 조회 | last in, first out (LIFO) /
first in, last out (FILO) | first in, first out
(FIFO) |
| 데이터 추가 | add(인덱스) | push(값) | offer(값) |
| 데이터 꺼내기 | get() | pop() | poll() |
- 위와 같이 데이터 저장 방식(메커니즘)에 따라 데이터를 꺼내는 방식이 다르다
    
    ⇒ 데이터 조회에 대해 일관성이 없다
    
- **일관된 호출**로 (메서드 시그너처) 통일돼야 한다.
    
    ⇒ 호출 규칙 정의 **“Iterator 구현체”** 사용 : `hasNext()` `next()`
    
    ```java
    # example
    public interface Iterator {
      boolean hasNext(); // 꺼낼 값이 있는지 검사할 때
      Object next(); // 값을 꺼낼 때
    }
    ```
    

iterator > listiterator > arraylist,linkedlist에iterator() 구현체 생성

boarddao 수정 > list.iterator() 부재 > 인터페이스 상속화 > dao toArray() 교체

### List와 Iterator 인터페이스

`Iterable` <<interface>> 

> List에 iterator() 직접 추가하지 않는 이유? (해당 인터페이스를 공유할 수도 있다는 가정)
> 

⇒ 여러 인터페이스에 공통으로 적용되는 규칙이 있다면, 수퍼인터페이스를 만들어 공통 규칙을 정의한 후, 상속 받는 것이 인터페이스 유지 보수에 좋다. (수퍼인터페이스가 필요한 이유)

⇒ **인터페이스 상속** (일반화됨)

<aside>
📍 @Override 로 확인 가능
따라서, 슈퍼클래스의 정의된 메서드, 추상화된 메서드 & 
인터페이스의 메서드 모두 재정의 가능

</aside>

⇒ 구현체 표현할 때, <<concrete>> 로 표기