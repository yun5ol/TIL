# Java (19) 인터페이스 계속, 중첩클래스

작업중: In progress
태그: Dev, 백엔드프로그래밍, 웹&모바일, 자바프로그래밍기초
학습일: 01/26/2023

## 인터페이스 상속과 구현

**package** com.eomcs.oop.ex09.c;

### 레퍼런스 상속, 구현

- 인터페이스를 구현할 때는 **수퍼 인터페이스의 메서드까지 모두 구현**해야 한다.
- 클래스/인터페이스&수퍼인터페이스 : 해당 인터페이스 내의 메서드로 한정된다 
**레퍼런스 사용에 따라 호출 범위가 달라진다**

### 인터페이스 다중 상속

- 인터페이스 다중상속 가능하다.
    - 왜? 구현된 상태가 아니기 때문에 = 인터페이스의 메서드는 추상메서드이기 때문에
    - 메서드 시그너처가 같으니 구현도 한번에 가능
    - 다중상속 불가능한 경우는?  메서드 시그너처가 하나라도 다를 때 (이름, 파라미터명, 리턴타입)

### 추상 클래스의 도움

- 추상 클래스에서 빈 바디(껍데기)로 미리 구현할 수 있다.
    - 이유는? 서브클래스에서 추상클래스를 상속 받아 
    인터페이스 규칙 중 필요한 규칙만 오바라이딩 할 수 있다. ⇒ 구현이 간결해진다.
- 추상 클래스 목적
    - 서브 클래스에게 공통 필드와 공통 메서드를 상속해 주는 것
    - 그 중에서 인터페이스에 선언된 메서드의 일부를 미리 구현해두면, 서브 클래스를 만들기 편리하다
- 추상 클래스에서 모든 메서드를 구현할 필요는 없다.
    - 추상 클래스에서 구현되지 않은 메서드는 반드시 서브 클래스에서 구현해야 한다.

### 인터페이스와 디폴트 메서드

- 수퍼 인터페이스 내 메서드가 수정될 때, 모든 서브 클래스에 메서드 추가, 수정, 구현이 별도로 이뤄져야 한다.
    
    ⇒ 유지 보수의 불편함 발생
    
    → 해결 방법 (셋 다 실무에서 사용)
    
    1. 새 메서드가 들어간 새 규칙을 정의 후, 기존 규칙을 상속받는다.
        
        → 기존에 진행된 모든 프로젝트들에 호환되지 않는다.
        
    2. 기존 인터페이스에 디폴트 메서드를 활용 후 각 클래스에서 오버라이딩한다.
        
        ```java
        public interface Computer {
        ...
        default void touch() {
            // 구현할 코드 있으면 작성하고, 없으면 빈 채로 둔다.
        		// 껍데기 구현 가능
          }
        }
        ```
        
        ⇒ 미리 구현된 메서드이기 때문에, 서브 클래스에 영향을 주지 않는다.
        
        ⇒ 이전 프로젝트들과 호환된다.
        
        ⇒ 기존 규칙을 변경하되, 기존 구현체(기존 규칙에 따라 작성한 클래스)에는 영향을 끼치고 싶지 않을 때
        
- 단점
    - 메서드 구현을 강제할 수 없다. ⇒ 인터페이스에서 미리 구현되었기 때문
        
        <aside>
        📍 따라서 **default** 문법은
        
        기존 인터페이스에 새 기능을 추가할 때만 가능한 사용하라.
        
        즉 기존에 그 인터페이스에 따라 이미 구현한 클래스들에
        
        영향을 끼치지 않기 위한 용도로만 사용하라.
        
        </aside>
        
    

---

## 중첩클래스 (nested class)

**package** com.eomcs.oop.ex11.a;

- 다른 클래스 안에 정의된 클래스
- 해당 클래스 안에서만 사용된다.
- 

특정 클래스 안에서만 사용되는 클래스가 있다면 중첩 클래스로 선언하라.
=> 즉 노출 범위를 좁히는 것이 유지보수에 좋다.

### 종류

1. static nested class
    
    ⇒ 바깥 클래스의 인스턴스에 종속되지 않는 클래스.
    
    ⇒ top level **class** 와 동일하게 사용한다.
    
    이 클래스를 소유하고 있는 클래스 뿐만 아니라 다른 클래스도 사용할 수 있다.
    
    `클래스명.중첩명`
    
2. non-static nested class = inner class
    
    => 바깥 클래스의 인스턴스에 종속되는 클래스.
    
    중첩 클래스에서 바깥 클래스의 인스턴스 멤버를 사용한다는 뜻이다.
    
    바깥 클래스의 인스턴스 없이 작업할 수 없는 경우
    
    중첩 클래스를 non-**static** nested **class** 로 정의한다.
    
    => 바깥 클래스의 인스턴스 없이 생성할 수 없다.
    
    1. 특정 인스턴스에 종속된 클래스인 경우 
3. local class
    1. 메서드 블록 안에 정의된 클래스
    2. 해당 메서드 블록에서만 사용된다.
    3. 필드나 메서드처럼 접근 제한자를 붙일 수 없다.
4. anonymous class (익명클래스)
    1. 객체 생성코드 + 클래스 정의
    2. 
    
    => 클래스의 이름이 없다.
    
    이름이 없으니, **new** 명령으로 따로 인스턴스를 생성할 수 없다.
    
    => 문법 = 클래스를 정의 하는 문법 + 인스턴스를 만드는 문법
    
    즉, 클래스를 정의하는 동시에 인스턴스를 생성해야 한다.
    
    => 클래스 이름이 없기 때문에 익명 클래스는 생성자를 정의할 수 없다.
    
    만약 인스턴스의 값을 초기화시키기 위해 복잡한 코드를 작성해야 한다면,
    
    "인스턴스 블록"을 사용하여 인스턴스 초기화 코드를 작성하라!
    
    => 단 한 개의 인스턴스만 생성해서 사용할 경우 익명 클래스를 적용한다.
    
    => 문법
    
    **new** 수퍼클래스() {수퍼 클래스를 상속 받은 익명 클래스 정의}
    
    **new** 인터페이스() {인터페이스를 구현한 익명 클래스 정의}
    
    => 주의!
    
    **new** **extends** 수퍼클래스 **implements** 인터페이스 {익명 클래스 정의} <== 이런 문법은 없다.
    
    수퍼 클래스를 지정하거나 인터페이스를 지정하거나 둘 중 하나만 해야 한다.
    
    ```java
    Object obj = new Object() {
          // Object 클래스를 상속 받은 익명 클래스를 만들고,
          // m1() 메서드를 추가한다.
          public void m1() {
            System.out.println("Hello!");
          }
        };
    ```
    

### 문법

- static
    
    중첩 클래스 내의 메서드는 탑레벨클래스의 인스턴스에 접근할 수 있으며, 클래스명 생략 가능하다.
    
    → 스태틱 멤버를 임포트 후, 클래스명 생략 가능
    

> 패키지 멤버 접근 범위
> 
> - public 으로 공개된 클래스는 다른 패키지에서 접근 할 수 있다.
> - public 으로 공개되지 않은 클래스는 다른 패키지에서 접근할 수 없다.
> - (**package-private**; modifier 가 없다) : 다른 패키지 접근 불가!≠ public
> 
> 같은 패키지 내에 존재하거나, public 으로 공개된 클래스거나
> 

---

### 23. 중첩 클래스 활용 AbstractList

1. LinkedList 클래스에서만 사용하는 클래스(Node.java)라면,
    
    LinkedList 클래스 안에 두는 것이 유지보수에 더 좋다. ⇒ 복붙, 수정 후 삭제
    
    패키지 외부에 노출되지 않고, 내부에서만 사용하니깐 ⇒ 다른 개발자가 헷갈릴 이유가 없다. 
    
    **public** > **static** 중첩클래스로 만든다. (**static** nested **class**) : node클래스
    
2. List 인터페이스를 사용하는 LinkedList와 ArrayList 사이의 공통점을 추상클래스로 (AbstractList)
    
    size, get(), Iterator()
    
    size : public > protected : 자식클래스가 접근 가능
    

- 중첩 클래스 사용 판단 기준 ⇒ 종류에 따라

> **static**
> 
> 
> ![Untitled](Java%20(19)%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%A8%E1%84%89%E1%85%A9%E1%86%A8,%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%8E%E1%85%A5%E1%86%B8%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B3%20061d5be289bb4b75adafcc469634a4a6/Untitled.png)
> 
> 1. 인스턴스 필드/메서드 사용 ⇒ 인스턴스 사용(this) 
> ⇒ 인스턴스 메서드가 되어야 한다
>     - LinkedList 외 다른 클래스는 Node 클래스를 사용하지 않는다. = nested class
>     - LinkedList 안에서는 모든 메서드가 Node클래스를 사용하며, 
>     인스턴스 필드(head, tail)를 사용한다. = instance method
> 2. 인스턴스 필드/메서드 사용 안함 ⇒ static method
> 
> **local class**
> 
> iterator() 메서드 안에서만 사용하는 클래스라면
> 이 메서드 안에 두는 것이 유지보수에 좋다. ⇒ local class
> 
> 바깥 클래스의 인스턴스를 사용하기 위해 생성자에서 그 주소를 받을 필요가 없다.
> 
> 왜? 컴파일러가 바깥 클래스의 객체 주소를 보관할 필드를 자동으로 생성하고,
> 
> 바깥 클래스의 객체 주소를 받을 수 있게 기존 생성자를 자동으로 변경한다.
> 
> 생성자가 없다면 바깥 클래스의 객체 주소를 받는 생성자를 자동으로 추가한다.
> 
> 따라서 다음과 같이 개발자과 직접 필드와 생성자를 추가할  필요가 없다.
> 
> => 쏘 편리
> 
> 대신 바깥 클래스의 인스턴스를 사용하려면 다음과 같이 객체를 지정해야 한다.
> 
> `바깥 클래스명.**this**.인스턴스멤버`
> 
> 로컬 클래스의 생성자를 호출할 때,
> 바깥 클래스의 인스턴스 주소를 넘길 필요가 없다.
> 컴파일러가 대신 처리한다.
> 바깥 클래스의 인스턴스 주소를 넘길 수 있도록 생성자 호출을 변경한다.
> 
> 1. 익명 클래스
>     
>     iterator() 메서드 안에서만 사용하는 클래스라면
>     이 메서드 안에 두는 것이 유지보수에 좋다. ⇒ local class
>     
>     → 인스턴스를 한 개만 만들어 사용하고, 클래스의 크기도 작다면,
>     
>     익명클래스로 만드는 것이 코드를 간결하게 한다.
>     
>     ```java
>     
>     인스턴스 생성  인터페이스  수퍼클래스생성자호출(Object)
>     Iterator obj = new Iterator() {
>     			…
>     }; // new 쓰면 세미콜론 필수
>     
>     Iterator obj = new Iterator() { 
>           int cursor;
>           @Override
>           public boolean hasNext() {
>             return cursor >= 0 && cursor < AbstractList.this.size();
>           }
>           @Override
>           public Object next() {
>             return AbstractList.this.get(cursor++);
>           }
>         };
>     
>         return obj;
>       }
>     ```
>     
>      
>     
>     익명클래스 +  return문 결합 ⇒ 중첩 클래스의 끝판왕
>     
>     ```java
>     public Iterator iterator() {
>     
>         return new Iterator() {
>           int cursor;
>           @Override
>           public boolean hasNext() {
>             return cursor >= 0 && cursor < AbstractList.this.size();
>           }
>           @Override
>           public Object next() {
>             return AbstractList.this.get(cursor++);
>           }
>         };
>       }
>     ```
>     
>     1. 백엔드 WebConfig 
>         
>         : SpringBoot  이용한 리팩토링
>         
>     
>     ```java
>     @SpringBootApplication
>     public class App {
>     
>       @Configuration(proxyBeanMethods = false)
>       public class MyCorsConfiguration {
>     
>         @Bean
>         public WebMvcConfigurer corsConfigurer() {
>           return new WebMvcConfigurer() {
>     
>             @Override
>             public void addCorsMappings(CorsRegistry registry) {
>               registry.addMapping("/**")
>               .allowedOrigins("http://localhost:5500", "http://127.0.0.1:5500")
>               .allowedMethods("*");
>             }
>           };
>         }
>       }
>     
>     }
>     ```
>     
>     cf.
>     
>     ![Untitled](Java%20(19)%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%A8%E1%84%89%E1%85%A9%E1%86%A8,%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%8E%E1%85%A5%E1%86%B8%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B3%20061d5be289bb4b75adafcc469634a4a6/Untitled%201.png)
>