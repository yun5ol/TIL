# Java (13) - 상속

작업중: In progress
태그: Dev, 백엔드프로그래밍, 웹&모바일, 자바프로그래밍기초
학습일: 01/13/2023

### 기능확장 방법

**package** com.eomcs.oop.ex05.a.test;

1. 기존 코드에 기능 추가
    
    <aside>
    📍 기존 코드를 변경하면 기존 코드를 사용해서 만든 프로그램에 영향을 준다.
    
    </aside>
    
    → 기존 클래스의 메서드를 함부로 수정하지 않는다.
    
2. 기존 코드를 복제 후 기능 추가
    
    기존 코드를 손대지 않기 때문에 이전에 작성한 프로그램에 영향을 주지 않는다.
    
    <aside>
    📍 기존 코드 버그 발생 또는 기능 추가 시, 복제된 모든 프로그램을 수정해야 한다.
    (온프레미스 on-premise : 자체 서버에 설치 ≠ 클라우드)
    
    </aside>
    
    → 유지보수가 힘들다.
    
3. 상속을 이용한 기능 확장
    
    기존 코드 변경 없이, 링크를 걸어 (extends) 기능 확장
    
    <aside>
    ✅ 기존 코드를 복사하는게 아니라, 사용 권한을 얻는 것
    기존 코드의 소스가 없어도 된다. bytecode (.class) 파일만 있으면 된다.
    
    </aside>
    
    → 다른 개발자가 만든 코드를 재사용 하기 쉽다.
    

> 기존 코드 변경 ⇒ 기존 메서드 재정의 ⇒ **“overriding 오버라이딩”** ≠ 오버로딩
> 
> 
> why? 슈퍼클래스의 코드를 서브클래스에 맞게
> 
> `@Override`
> 
> 컴파일러에게 재정의를 제대로 했는지 검사해달라고 서비스를 요청하는 명령
> 
> 해당 메서드 앞에 스티커를 붙여준다.
> 

### 상속의 실질적 의미

- 슈퍼 클래스가 획득한 슈퍼슈퍼 클래스의 메서드를 호출할 수 있다.
- 슈퍼 클래스는 하위를 가리킬 수 있으나, 상위는 가리킬 수 없다.
- 클래스는 한 번만 로딩되므로, static 블록도 한 번만 실행된다.

- 컴파일러는 변수(레퍼런스)의 타입에서 메서드를 찾아 올라간다.
    
    ⇒ **레퍼런스가 실제 어떤 클래스의 인스턴스를 가리키는 것인지 따지지 않는다.**
    

![Untitled](Java%20(13)%20-%20%E1%84%89%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8%2053c70ed3470c4bc1a2a14ba95b663c48/Untitled.png)

### 상속과 메서드 호출

### 상속과 클래스 로딩

- 인스턴스 생성 절차
    
    1) 상속 받은 수퍼 클래스를 먼저 메모리에 로딩한다.
        이미 로딩되어 있다면 다시 로딩하지는 않는다.
    2) 그런 후 해당 클래스를 메모리에 로딩한다.
        마찬가지로 이미 로딩되어 있다면 다시 로딩하지는 않는다.
     3) 수퍼 클래스에 선언된 대로 인스턴스 변수를 Heap에 만든다.
     4) 해당 클래스에 선언된 대로 인스턴스 변수를 Heap에 만든다.
     5) 수퍼 클래스부터 생성자를 실행하며 해당 클래스까지 내려온다.
    
    // 그래서 인스턴스를 생성할 때는 항상 상속 받아야 하는 클래스 파일이 모두 있어야 한다.
    

> 
> 
> 
> ### 생성자 호출 순서
> 
> <aside>
> ✅ 해당 클래스의 생성자를 호출하면,
> 그 생성자의 첫 번째 문장이 수퍼 클래스의 생성자를 호출하는 명령이다.
> 
> </aside>
> 
> ![**package** com.eomcs.oop.ex05.g;](Java%20(13)%20-%20%E1%84%89%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8%2053c70ed3470c4bc1a2a14ba95b663c48/Untitled%201.png)
> 
> **package** com.eomcs.oop.ex05.g;
> 
> 1. 인스턴스 필드 생성
> 2. 생성자 호출
>     - 클래스를 정의할 때 수퍼 클래스를 지정하지 않으면,  컴파일러는 자동으로 수퍼 클래스를 java.lang.Object 클래스로 지정한다.
>     - 수퍼 클래스의 어떤 생성자를 호출할지 지정하지 않으면, 컴파일러는 다음과 같이 수퍼 클래스의 기본 생성자를 호출하라는 명령을 **생성자의 첫 줄에 추가**한다.
>         
>         **`super**();`  즉 개발자가 붙이지 않으면 **자동**으로 붙인다.
>         

### 수퍼 클래스에 기본 생성자 없는 경우

`Implicit super constructor A() is undefined. Must explicitly invoke another constructor`

→ 직접 수퍼 클래스에 있는 생성자로 호출해야 한다

→ 기본 생성자 호출 시 컴파일 오류

### 다중 상속

자바는 다중 상속을 지원하지 않는다.

**`public** **class** C **extends** A, B {` ⇒ xx

어떤 클래스의 설계도를 따라야할지 오류

## 상속

---

### Specialization 전문화

기존(슈퍼) 클래스를 상속받아 특별한 기능을 덧붙이거나 재정의한다.

이전의 클래스 코드 또한 사용할 수 있다

### Generalization 일반화

기존의 여러 클래스에 중복되는 코드를 하나의 클래스로 별도 추출하여 상속관계를 맺는다.

= 서브 클래스들의 공통 필드/메서드를 추출해서 슈퍼 클래스로 만드는 것

<aside>
📍 관리 용이를 위해 만든 클래스
⇒ 사용하려고 만든 클래스가 아니다.
⇒ 일반용으로 쓰지 못하도록 막는 것이 관리에 좋다.

> **추상클래스로 선언한다.**
> 
</aside>

### 추상 클래스

서브클래스에게 공통 기능을 상속해주는 목적으로 만든 클래스이다.

직접 사용하지 않는 클래스이다.

상속 일반화는 주로 추상클래스를 선언한다.

`abstract class 클래스명 {...}`

서브클래스의 공통 코드를 추출했다고 캐치할 수 있다.

```java
# 예제
public abstract class Car {

  public Car() {
    super();
  }
...
```

### 추상 메서드 ↔ concrete

서브 클래스마다 다르게 정의해야 하는 메서드라면, 

슈퍼 클래스에서 정의하지 말고 서브 클래스에서 정의하도록 강제시키는 문법

- 추상 메서드는 추상 클래스 안에서만 존재한다.
- 메시지 바디가 없다.

```java
public void run() {
    System.out.println("달린다");
  };
```

```java
public abstract void run();
```
