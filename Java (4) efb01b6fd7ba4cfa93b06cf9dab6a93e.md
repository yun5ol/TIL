# Java (4)

작업중: In progress
태그: Dev, 백엔드프로그래밍, 웹&모바일, 자바프로그래밍기초
학습일: 12/29/2022

### 객체지향 Language의 기본 문법

값을 표현하는 문법
값을 저장하는 문법
값을 다루는 문법
실행 흐름을 제어하는 문법
명령문을 기능에 따라 묶는 문법
관련된 메서드를 묶는 문법
새 데이터 타입을 정의하는 문법
코드 재사용을 높이는 문법
코드 유지보수를 쉽게하는 문법

Literal
Variables
Operators
Statement
Method
Class (Abstraction)

Inheritance, Polymorphism, Encapsulation
Abstract class, Interface, Nested class

## Variables

### 변수 선언

**값을 담는 메모리를 준비시키는 문법** (선언, 생성x)

변수에 저장할 값의 종류(데이터 타입)에 따라 변수 타입 상이

변수에는 2진수 정수값만 저장

- 기본문법

`데이터타입 변수명;`

### 변수 타입별 메모리

각 타입의 변수가 저장할 수 있는 값의 범위가 한정

예외조건) 리터럴 값이 메모리 보다 크기가 크더라도, 담을 수 있다면 허용된다.                                                                                     

Java 원시 타입 : primitive data type (기본형) / 그 외는 Class : reference data type (참조형) eg. String

| 데이터 타입  | 1Byte | 2Byte | 4Byte | 8Byte |
| --- | --- | --- | --- | --- |
| 정수 | byte | short | int | long |
| 부동소수점 |  |  | float | double |
| 논리값 | ‘배열로 선언 시’ |  | boolean |  |
| 문자 |  | char |  |  |

```java
	storage location
int a;
a = 100;
할당연산자, assignment

## 자바는 ;세미콜론 필수, 생략 불가
```

> **Java 변수 Summary**
> 
> 
> 
> - l-value 와 r-value
>     
>     할당 연산자 기준 
>     
>     좌측 : l-value → 반드시 메모리
>     
>     우측 : r-value → 반드시 값 (eg. 결과가 return되는 문장 =expression =메서드호출
>     
>     “오른쪽에 지정된 값을 왼쪽 변수가 가리키는 메모리에 저장”
>     
> - 호이스팅 없다
> - 한 블록 안에서 같은 이름의 변수 중복선언 불가
> - 변수에 값 저장 필수
> - char 변수는 음수 개념이 없다.
>     
>     ![eg. 게토레이, 워셔액 ](Java%20(4)%20efb01b6fd7ba4cfa93b06cf9dab6a93e/Untitled.png)
>     
>     eg. 게토레이, 워셔액 
>     
>     > `System.out.println(c);`
>     > 
>     > 1. 현재 프로그램에서 사용하는 폰트 파일을 찾는다. → D2Coding
>     > 2. D2Coding 폰트 파일에서 65에 해당하는 문자를 찾는다. → A
>     > 3. 폰트 파일에서 읽은 A 문자 그림을 출력한다.
> - ‘ ‘ 연산자는 문자를 저장하는게 아니라, 문자의 **코드값 (정수)이다.**

### 배열

같은 종류의 메모리를 여러개 생성할 때 사용하는 문법 ⇒ [연속된 메모리 (변수들이 개별적이지 않다)](https://www.notion.so/abd415de274a4afe9eb95ee0e325f05b)

- 기본문법
    - 배열 선언
        
        `데이터타입[] 변수명;`
        
        또는 `데이터타입 변수명[];` → C Style
        
    - 배열 생성
        
        `변수명 = new 데이터타입[길이];`
        
    - 선언 및 생성 한번에 가능
        
        <aside>
        📍 `데이터타입[] 변수명 = new 데이터타입[길이];`
        
        `변수명` : 배열 메모리의 **주소**를 담는 변수 "**reference”**
        `new` : 사용할 메모리를 확보
        
        new 명령을 통해 준비한 메모리 **“인스턴스 (instance)”**
        
        JVM은 **Heap 영역**에 연속된 int 타입의 메모리를 준비한다. 
        
        리턴 값을 준비한 메모리의 시작 주소이다.
        
        </aside>
        

- 래퍼런스만 따로 선언 가능
- 배열 인스턴스 생성 후 → 래퍼런스에 주소 저장 순서
- 언제든 배열 인스턴스의 주소를 다른 레퍼런스에 담을 수 있다.
- 배열 레퍼런스 초기화
    - 배열 메모리의 기본 초기화 값은 ‘0’ `arr1 = **null**;`

### 배열 메모리에 접근

- 기본문법
    
    `배열변수[인덱스] = 값;`
    
    - 배열 선언 + 초기화
     `데이터타입[] 변수명 = new 데이터타입[]{값, 값, 값};`
    배열 메모리를 초기화시킬 때는 배열 개수를 지정해서는 안된다.
    배열을 초기화시키는 값의 개수 만큼 메모리가 만들어진다.
    new 명령을 생략할 수 있다.
    - 배열 선언 후 따로 배열 초기화 문장 실행
    `데이터타입[] 변수명;`
    `변수명 = new 데이터타입[]{값, 값, 값};`
    변수를 선언한 후 따로 배열을 초기화시킬 때는 new 명령을 생략할 수 없다.

<aside>
📍 인덱스가 없는데 값이 할당될 경우 = 실행오류 (runtime exception) = ArrayIndexOutOfBound ≠ Compile Error

</aside>

```java
// 배열 메모리를 **특정 값으로 초기화**
    arr1[0] = 100;
    arr1[1] = 90;
    arr1[2] = 80;
    arr1[3] = 70;
    arr1[4] = 60;

// 1) 배열 선언 + 초기화 명령
    int[] arr2 = new int[]{100, 90, 80, 70, 60}; // OK!
    //int[] arr2 = new int[5]{100, 90, 80, 70, 60}; 
		// 문법오류! 초기화 할 때 배열 개수 지정하면 안된다.

    // 2) 배열 선언 + 초기화 명령 II
    int[] arr3 = {100, 90, 80, 70, 60}; // new int[] 생략 가능

    // 그러나 배열 변수를 선언한 후 따로 초기화시킬 때는
    // 다음과 같이 new 명령을 생략할 수 없다.
    int[] arr4;
    //    arr4 = {100, 90, 80, 70, 60}; // 컴파일 오류!

    // 배열 초기화 명령을 따로 실행할 때는 new int[] 를 생략할 수 없다.
    int[] arr5;
    arr5 = new int[]{0, 0, 0, 0, 0};
  }
}
```

### 배열 인스턴스와 가비지 (garbage)

인스턴스의 주소를 잃어버려 사용할 수 없는 상태의  인스턴스

```java
public class Exam0580 {
  public static void main(String[] args) {

    int[] arr1;
    arr1 = new int[5];
    arr1[0] = 100;
    
    // 레퍼런스에 다른 배열 인스턴스의 주소를 담을 수 있다.
    arr1 = new int[] {200, 200, 200};
}
// int[5]는 주소를 잃어버렸다 "Garbage"
```

- Garbage Collector 에 의해 자동으로 메모리 해제된다. = 잠금장치를 풀어서 다른 용도로 재사용 할 수 있게 만든다.
- 가비지 수집 조건 = 가비지 컬렉터가 동작할 때 ← 자동화
    - 메모리가 부족할 때
    - CPU가 한가할 때
- **가비지와 JVM 레퍼런스 카운트**
    
    

---

### 변수 종류

### 형변환

- 명시적 형변환
    - 컴파일러에게 강제로 값을 넣을 것을 명령
    - 큰 메모리의 값을 작은 메모리로 변환 할 때
- 기본문법
    
    `변수 = (바꾸려는타입명)변수 또는 값;`
    

예제

```java
float f = 3.14f;
int i = (int)f;  // 소수점 이하가 제거된다.
System.out.println(i);
```

- 형변환이 가능한 경우
    - 정수 메모리끼리 형변환이 가능하다.
    - 부동소수점을 정수로 형변환이 가능한다.
    - 형변환 없이 정수는 부동소수점 메모리에 저장할 수 있다.
    - 숫자를 문자 코드로 형변환 가능한다.
    // 그 외에는 형변환 불가! ⇒ 특별한 메서드가 있긴 함