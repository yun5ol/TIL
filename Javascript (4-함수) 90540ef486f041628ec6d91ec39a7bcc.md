# Javascript (4-함수)

교재: Do it! 웹표준의정석
작업중: In progress
태그: Dev, 웹&모바일, 웹프로그래밍기초
학습일: 12/08/2022

## 함수

### 정의

1. 데이터 타입이 없기 때문에 함수의 리턴 타입을 지정하지 않는다.
2. function 키워드로 시작한다.
3. 파라미터는 괄호 안에 선언한다.
    
    파라미터는 var 붙이지 않는다, 붙이면 안된다.
    
    파라미터가 없어도 빈 괄호를 지정해야 한다.
    
4. 값을 리턴할 때는 return 키워드를 쓴다.

```jsx

function prototype (c/c++)
=method signature (java)

**function 함수명(파라미터, 파라미터, ...) {
	명령문
...
	return 표현식;**     (expression : 값을 리턴하는 방식)    **=> function body (몸체)**
**}**                      eg. 리터럴 : "aaa", 20, true, {-}, []
								             변수 : a, score, sum ... 
									             식 : a = "hello", a * 2, 함수호출 ...
  
함수호출 ( 함수를 실행시키는 명령 )
⬇
함수명(값, 값, ...);
			argument (파라미터와 섞어쓰기도 함)

ex03 > 
# exam01

function f1() { // 파라미터가 없는 함수
	console.log("안녕!");
}

function f2() { // 값을 리턴하는 함수
	return "안녕2!";
}

function f3(a, b) { // 파라미터 있는 함수
	// 물론 파라미터도 로컬 변수이기 때문에 함수 호출이 끝나면 제거된다.
	console.log(a, "+", b, "=", (a + b));
}

function f4(a, b) { // 파라미터도 있고, 리턴 값도 있는 함수
	return a + b;
}

f1(); // 함수 호출
console.log("----------------");

console.log(f2());
console.log("----------------");

f3(10, 20);
console.log("----------------");

console.log(f4(10, 20));
console.log("----------------");

# 02-1

<h1>함수 - 함수의 파라미터와 아규먼트</h1>
// 자바스크립트 함수를 호출할 때 아규먼트의 개수는 
// 함수에 정의된 파라미터 개수와 일치하지 않아도 된다. 
// 아규먼트(argument)? 함수를 **호출할 때 전달하는 값.**
// 파라미터(parameter)? 함수를 호출할 때 **전달한 값을 보관하는 함수의 로컬 변수**

<script>
// 자바스크립트 함수를 호출할 때 아규먼트의 개수는 
// 함수에 정의된 파라미터 개수와 일치하지 않아도 된다. 
// 아규먼트(argument)? 함수를 호출할 때 전달하는 값.
// 파라미터(parameter)? 함수를 호출할 때 전달한 값을 보관하는 함수의 로컬 변수.
function f1(a) { 
	console.log(a);
}

f1(100); // 한 개의 파라미터에 저장할 값을 한 개 전달한다.

// 그런데 자바스크립트는 파라미터의 개수와 상관없이 값을 마음대로 전달할 수 있다.
f1(); // 없으니깐 undefined

// 파라미터 개수보다 더 많은 값을 전달해도 된다. 
f1(100, 200, 300, 400);

// 그러면 파라미터 개수를 초과하여 전달한 값은 어디로?
// => 다음 예제를 보라!
</script>

# 02-2

<h1>함수 - 함수 오버로딩?</h1>

// 같은 이름의 함수를 여러 개 선언
// => 문법 오류가 아니다.
// => 단지 기존 함수를 대체한다.
// => 따라서 자바스크립트는 자바 또는 c++ 언어에서 제공하는 "메서드 오버로딩"을 지원하지 않는다.

# 03-1 ~2 여기부터 다시 볼 것

# 04
<h1>함수 - 함수와 window 객체</h1>

window.f1("안녕1"); // 아래와 같은 말이다.
window["f1"]("안녕3"); // f1 이름으로 저장된 함수 주소를 가져와서 호출한다.

```

> 
> 
> 
> ```jsx
> # 리마인드
> 
> var obj = {
> 	name: "홍길동"
> 	"age": 20,
> 	'tel': 1111-1111
> };
> 
> console.log(obj.name)
> console.log(obj["name"]) // 프로퍼티는 무조건 대괄호에 문자열 > 대괄호만 있으면 안돼
> 
> console.log(a);
> console.log(window.a);
> console.log(window["a"]); // 대괄호 프로퍼티 이름을 주거나
> console.log(window['a']); // 싱글, 더블 따지지 않는다
> ```
> 

```jsx
# 05

```

> 08
> 
> 
> ![Untitled](Javascript%20(4-%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE)%2090540ef486f041628ec6d91ec39a7bcc/Untitled.png)
> 
> 변수 선언만 위로 올라가고, 할당문은 호이스팅 되지 않는다.
> 

### Closure

11-1 

함수 안에 정의된 함수

클로저에서 바깥 함수의 로컬 변수를 사용할 때,

바깥 함수의 호출이 끝나면 해당 로컬 변수는 제거되어 클로저는 존재하지 않는 변수를 사용하는 상황이 발생한다.

그래서 이런 경우를 방지하고자,

**클로저에서 사용하는 바깥 함수의 로컬 변수는 클로저의 별도 메모리에 복제된다.**

![Untitled](Javascript%20(4-%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE)%2090540ef486f041628ec6d91ec39a7bcc/Untitled%201.png)