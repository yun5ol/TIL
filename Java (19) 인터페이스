# Java (19) 인터페이스 

작업중: In progress
태그: Dev, 백엔드프로그래밍, 웹&모바일, 자바프로그래밍기초
학습일: 01/26/2023

## 인터페이스 상속과 구현

**package** com.eomcs.oop.ex09.c;

### 레퍼런스 상속, 구현

- 인터페이스를 구현할 때는 **수퍼 인터페이스의 메서드까지 모두 구현**해야 한다.
- 클래스/인터페이스&수퍼인터페이스 : 해당 인터페이스 내의 메서드로 한정된다 
**레퍼런스 사용에 따라 호출 범위가 달라진다**

### 인터페이스 다중 상속

- 인터페이스 다중상속 가능하다.
    - 왜? 구현된 상태가 아니기 때문에 = 인터페이스의 메서드는 추상메서드이기 때문에
    - 메서드 시그너처가 같으니 구현도 한번에 가능
    - 다중상속 불가능한 경우는?  메서드 시그너처가 하나라도 다를 때 (이름, 파라미터명, 리턴타입)

### 추상 클래스의 도움

- 추상 클래스에서 빈 바디(껍데기)로 미리 구현할 수 있다.
    - 이유는? 서브클래스에서 추상클래스를 상속 받아 
    인터페이스 규칙 중 필요한 규칙만 오바라이딩 할 수 있다. ⇒ 구현이 간결해진다.
- 추상 클래스 목적
    - 서브 클래스에게 공통 필드와 공통 메서드를 상속해 주는 것
    - 그 중에서 인터페이스에 선언된 메서드의 일부를 미리 구현해두면, 서브 클래스를 만들기 편리하다
- 추상 클래스에서 모든 메서드를 구현할 필요는 없다.
    - 추상 클래스에서 구현되지 않은 메서드는 반드시 서브 클래스에서 구현해야 한다.

### 인터페이스와 디폴트 메서드

- 수퍼 인터페이스 내 메서드가 수정될 때, 모든 서브 클래스에 메서드 추가, 수정, 구현이 별도로 이뤄져야 한다.
    
    ⇒ 유지 보수의 불편함 발생
    
    → 해결 방법 (셋 다 실무에서 사용)
    
    1. 새 메서드가 들어간 새 규칙을 정의 후, 기존 규칙을 상속받는다.
        
        → 기존에 진행된 모든 프로젝트들에 호환되지 않는다.
        
    2. 기존 인터페이스에 디폴트 메서드를 활용 후 각 클래스에서 오버라이딩한다.
        
        ```java
        public interface Computer {
        ...
        default void touch() {
            // 구현할 코드 있으면 작성하고, 없으면 빈 채로 둔다.
        		// 껍데기 구현 가능
          }
        }
        ```
        
        ⇒ 미리 구현된 메서드이기 때문에, 서브 클래스에 영향을 주지 않는다.
        
        ⇒ 이전 프로젝트들과 호환된다.
        
        ⇒ 기존 규칙을 변경하되, 기존 구현체(기존 규칙에 따라 작성한 클래스)에는 영향을 끼치고 싶지 않을 때
        
- 단점
    - 메서드 구현을 강제할 수 없다. ⇒ 인터페이스에서 미리 구현되었기 때문
        
        <aside>
        📍 따라서 **default** 문법은
        
        기존 인터페이스에 새 기능을 추가할 때만 가능한 사용하라.
        
        즉 기존에 그 인터페이스에 따라 이미 구현한 클래스들에
        
        영향을 끼치지 않기 위한 용도로만 사용하라.
        
        </aside>
        
    

---
